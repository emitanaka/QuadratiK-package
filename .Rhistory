val2 <- validation(pkbc(dat, c(2,3,4)), true_label = y, elbow.plot = TRUE)
librarÃ¹
library(testthat)
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
devtools::document()
summary_stat(pkbd_res, 4)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
res1$metrics
expect_equal(length(res1$metrics), 2)
# Test 1: Test for summary_stat
test_that("summary_stat test", {
# dimension = 2
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 2)
expect_equal(length(res2$metrics), 2)
# dimension = 3
dat<-rbind(matrix(rnorm(60),ncol=3), matrix(rnorm(60,4),ncol=3), matrix(rnorm(60,2),ncol=3))
y <- rep(c(1,2,3),each=20)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 3)
expect_equal(length(res2$metrics), 3)
# dimension = 4
dat<-rbind(matrix(rnorm(60),ncol=4), matrix(rnorm(60,4),ncol=4), matrix(rnorm(60,2),ncol=4))
y <- rep(c(1,2,3),each=15)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 4)
expect_equal(length(res2$metrics), 4)
})
roxygen2::roxygenize()
devtools::document()
roxygen2::roxygenize()
roxygen2::roxygenize()
devtools::document()
library(pkgcheck)
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
x <- pkgcheck("C:/Users/sarac/Documents/GitHub/QuadratiK-package")
summary(x)
print(x)
library(testthat)
library(QuadratiK)
# Test 7: Testing main functionality: k-sample test
test_that("Functionality with valid inputs", {
x <- matrix(rnorm(100), ncol = 2)
y <- rep(c(1,2), each=25)
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance k-sample test")
expect_true(is.numeric(result@Dn))
expect_false(result@H0)
# Test all the methods for computing the CV
result <- kb.test(x, y, h=0.5, method = "bootstrap")
expect_s4_class(result, "kb.test")
result <- kb.test(x, y, h=0.5, method = "permutation")
expect_s4_class(result, "kb.test")
})
# x is none of these
expect_error(kb.test(x = matrix("invalid",nrow=10,ncol=2), h=0.5), "x must be a matrix or a data.frame", fixed=TRUE)
# x is none of these
expect_error(kb.test(x = list("invalid"), h=0.5), "x must be a matrix or a data.frame", fixed=TRUE)
roxygen2::roxygenize()
# x is none of these
expect_error(kb.test(x = matrix("invalid",nrow=10,ncol=2), h=0.5), "x must be a matrix or a data.frame", fixed=TRUE)
# x is none of these
expect_error(kb.test(x = "invalid", h=0.5), "x must be a matrix or a data.frame", fixed=TRUE)
roxygen2::roxygenize()
devtools::document()
# Test 5: Correct handling of vector x input
test_that("Handle vector x input correctly", {
# x is a vector
result <- kb.test(x = rnorm(10), h=0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance Normality test")
# x is a data.frame
result <- kb.test(x = data.frame(matrix(rnorm(20),ncol=2)), h=0.5)
expect_s4_class(result, "kb.test")
# x is a matrix
result <- kb.test(x = matrix(rnorm(20),ncol=2), h=0.5)
expect_s4_class(result, "kb.test")
# x is not numeric
expect_error(kb.test(x = "invalid", h=0.5), "x must be numeric", fixed=TRUE)
# x is not matrix or data.frame
expect_error(kb.test(x = list(rnorm(10),rnorm(10)), h=0.5), "x must be a matrix or a data.frame", fixed=TRUE)
})
# x is a vector
result <- kb.test(x = rnorm(10), h=0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance Normality test")
# x is a data.frame
result <- kb.test(x = data.frame(matrix(rnorm(20),ncol=2)), h=0.5)
roxygen2::roxygenize()
# x is a vector
result <- kb.test(x = rnorm(10), h=0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance Normality test")
# x is a data.frame
result <- kb.test(x = data.frame(matrix(rnorm(20),ncol=2)), h=0.5)
expect_s4_class(result, "kb.test")
# x is a matrix
result <- kb.test(x = matrix(rnorm(20),ncol=2), h=0.5)
expect_s4_class(result, "kb.test")
# x is not numeric
expect_error(kb.test(x = "invalid", h=0.5), "x must be numeric", fixed=TRUE)
# x is not matrix or data.frame
expect_error(kb.test(x = list(rnorm(10),rnorm(10)), h=0.5), "x must be a matrix or a data.frame", fixed=TRUE)
is.numeric(matrix("ok",ncol=2))
is.numeric(c("ok",ncol=2))
rnorm(10)
# Test if y is a data.frame
y <- data.frame(matrix(rnorm(100), ncol = 2))
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
x <- matrix(rnorm(100), ncol = 2)
# Test if y is a data.frame
y <- data.frame(matrix(rnorm(100), ncol = 2))
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
library(testthat)
expect_type(result@h, "numeric")
result@h
expect_type(result@h$h_sel, "numeric")
expect_class(result@h$h_sel, "numeric")
result@h$h_sel
typeof(result@h$h_sel)
class(result@h$h_sel)
expect_equal(class(result@h$h_sel), "numeric")
# Test 8: Testing selection of h
test_that("Selection of h from kb.test", {
x <- matrix(rnorm(100), ncol = 2)
y <- rep(c(1,2), each=25)
result <- kb.test(x, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance Normality test")
expect_equal(class(result@h$h_sel), "numeric")
result <- kb.test(x, y, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(class(result@h$h_sel), "numeric")
})
# Test additional errors
y <- matrix(rnorm(80), ncol = 2)
expect_error(kb.test(x, y, h=0.5),"'x' and 'y' must have the same number of columns.", fixed=TRUE)
kb.test(x, y, h=0.5)
# Test additional errors
y <- matrix(rnorm(80), ncol = 2)
kb.test(x, y, h=0.5)
x <- matrix(rnorm(100), ncol = 2)
# Test additional errors
y <- matrix(rnorm(80), ncol = 2)
kb.test(x, y, h=0.5)
length(unique(y))
K > K_threshold
# Test additional errors
y <- matrix(rnorm(90), ncol = 3)
expect_error(kb.test(x, y, h=0.5),"'x' and 'y' must have the same number of columns.", fixed=TRUE)
# Test parametric centering
result <- kb.test(x, y, h=0.5, method = "bootstrap", centeringType = "Param")
x <- matrix(rnorm(100), ncol = 2)
y <- matrix(rnorm(100), ncol = 2)
# Test parametric centering
result <- kb.test(x, y, h=0.5, method = "bootstrap", centeringType = "Param")
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance two-sample test")
# Test additional errors
y <- rep(c(1,2), each=20)
expect_error(kb.test(x, y, h=0.5),"'x' and 'y' must have the same number of rows.", fixed=TRUE)
# test show method
output <- capture.output(show(result))
expect_true(grepl("H0 is rejected: ", output))
grepl("H0 is rejected: ", output)
output
show(result)
expect_true(grepl("H0 is rejected: ", show(result)))
grepl("H0 is rejected: ", show(result))
expect_true(grepl("Test Statistic: ", output))
expect_true(grep("Test Statistic: ", output))
grep("Test Statistic: ", output)
grepl("Test Statistic: ", output)
expect_true(any(grepl("Test Statistic: ", output)))
# test summary method
s <- summary(result)
s
expect_type(s$summary_tables, "list")
x <- matrix(rnorm(100), ncol = 2)
y <- rep(c(1,2), each=25)
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance k-sample test")
expect_true(is.numeric(result@Dn))
expect_false(result@H0)
# test show method
output <- capture.output(show(result))
expect_true(any(grepl("H0 is rejected: ", show(result))))
expect_true(any(grepl("H0 is rejected: ", output)))
expect_true(any(grepl("Test Statistic: ", output)))
# test summary method
s <- summary(result)
expect_type(s$summary_tables, "list")
x <- matrix(rnorm(100), ncol = 2)
y <- matrix(rnorm(100), ncol = 2)
result <- kb.test(x, y, h=0.5, method = "subsampling", b = 0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance two-sample test")
expect_true(is.numeric(result@Dn))
expect_false(result@H0)
# test summary method
s <- summary(result)
expect_type(s$summary_tables, "list")
expect_equal(nrow(s$test_results), 2)
# x is a vector
result <- kb.test(x = rnorm(10), h=0.5)
expect_s4_class(result, "kb.test")
expect_equal(result@method, "Kernel-based quadratic distance Normality test")
# test summary method
s <- summary(result)
expect_type(s$summary_tables, "list")
# x is a matrix
result <- kb.test(x = matrix(rnorm(20),ncol=2), h=0.5)
expect_s4_class(result, "kb.test")
# test summary method
s <- summary(result)
expect_type(s$summary_tables, "list")
s$summary_tables
class(s$summary_tables)
# test summary method
s <- summary(result)
expect_equal(class(s$summary_tables), "matrix")
expect_true("matrix" %in% class(s$summary_tables))
"matrix" %in% class(s$summary_tables)
expect_true("matrix" %in% class(s$summary_tables))
expect_equal(nrow(s$test_results), 1)
size <- 100
d <- 3
set.seed(012924)
x_sp <- sample_hypersphere(d, n_points=size)
unif_test <- pk.test(x_sp,rho=0.8)
expect_s4_class(unif_test, "pk.test")
expect_true(is.numeric(unif_test@Un))
expect_true(is.numeric(unif_test@Vn))
expect_false(unif_test@H0_Un)
# test show method
output <- capture.output(show(unif_test))
expect_true(any(grepl("H0 is rejected: ", output)))
expect_true(any(grepl("Test Statistic: ", output)))
output
# test summary method
s <- summary(unif_test)
type(s$summary_tables)
typeof(s$summary_tables)
expect_type(s$summary_tables, "list")
s$test_results
expect_equal(nrow(s$test_results), 2)
roxygen2::roxygenize()
devtools::document()
library(testthat)
# Test 1: Error on Invalid x Input
test_that("Error on invalid x input", {
expect_error(pk.test(x = "Not matrix", rho = 0.5),
"x must be numeric", fixed=TRUE)
expect_error(pk.test(x = rnorm(50), rho = 0.5),
"x must be a matrix or a data.frame with dimension greater than 1.", fixed=TRUE)
})
# Test 2: Error on Invalid Quantile Input
test_that("Error on invalid Quantile input", {
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = 0.5,
Quantile = 1.1), "Quantile must be in (0,1]",
fixed=TRUE)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = 0.5,
Quantile = -1), "Quantile must be in (0,1]",
fixed=TRUE)
})
# Test 3: Error on Invalid rho Input
test_that("Error on invalid rho input", {
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = -0.1),
"rho must be in (0,1)", fixed=TRUE)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = 2),
"rho must be in (0,1)", fixed=TRUE)
})
# Test 4: Handling Vector x Input
test_that("Handle vector x input correctly", {
expect_s4_class(pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5),
"pk.test")
expect_s4_class(pk.test(x = data.frame(matrix(rnorm(100), ncol = 2)),
rho = 0.5), "pk.test")
})
expect_s4_class(pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5),
"pk.test")
pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5)
debug(pk.test)
pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5)
devtools::document()
pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5)
# Test 4: Handling Vector x Input
test_that("Handle vector x input correctly", {
expect_s4_class(pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5),
"pk.test")
expect_s4_class(pk.test(x = data.frame(matrix(rnorm(100), ncol = 2)),
rho = 0.5), "pk.test")
})
# Test 5: Main Functionality with Valid Inputs
test_that("Functionality with valid inputs", {
size <- 100
d <- 3
set.seed(012924)
x_sp <- sample_hypersphere(d, n_points=size)
unif_test <- pk.test(x_sp,rho=0.8)
expect_s4_class(unif_test, "pk.test")
expect_true(is.numeric(unif_test@Un))
expect_true(is.numeric(unif_test@Vn))
expect_false(unif_test@H0_Un)
# test show method
output <- capture.output(show(unif_test))
expect_true(any(grepl("H0 is rejected: ", output)))
expect_true(any(grepl("Statistic Un: ", output)))
expect_true(any(grepl("Statistic Vn: ", output)))
# test summary method
s <- summary(unif_test)
expect_type(s$summary_tables, "list")
expect_equal(nrow(s$test_results), 2)
})
#------------------------------------------------------
## Generating data point on the Sphere
## and computing the densities
den <- dpkb(pkbd_dat$x, mu, rho)
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejvmf")
# Check the errors
# mu
expect_error(dpkb(pkbd_dat$x, mu = c(1,0), rho = 0.8), 'mu must have length >= 2')
# Check the errors
# mu
expect_error(dpkb(pkbd_dat$x, mu = c(1), rho = 0.8), 'mu must have length >= 2')
expect_error(dpkb(pkbd_dat$x, mu = c(0,0,0), rho = 0.8), 'Input argument mu cannot be a vector of zeros')
expect_error(dpkb(rnorm(10), mu = c(0,0,0), rho = 0.8), "x must be a matrix or a data.frame")
expect_error(dpkb(matrix(rnorm(10),ncol=1), mu = c(0,0,0), rho = 0.8), 'x must have dimension >= 2')
expect_error(dpkb(pkbd_dat$x, mu = c(1,0,0), rho = 2), 'Input argument rho must be within [0,1)')
dpkb(pkbd_dat$x, mu = c(1,0,0), rho = 2)
library(testthat)
test_that("Random Generation from PKBD works", {
# Check the errors
expect_error(rpkb(10, mu = c(1,0,0), rho = 2), 'Input argument rho must be within [0,1)',fixed=TRUE)
expect_error(rpkb(10, mu = c(0,0,0), rho = 0.8), 'Input argument mu cannot be a vector of zeros',fixed=TRUE)
expect_error(rpkb(-10, mu = c(1,0,0), rho = 0.8), 'n must be a positive integer',fixed=TRUE)
expect_error(rpkb(10, mu = c(1,0,0), rho = 0.8, method = "invalid"), 'Unknown method',fixed=TRUE)
#------------------------------------------------------
## Generating data point on the Sphere
## "rejvmf"
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejvmf")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
## "rejacg"
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejacg")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
## "rejpsaw"
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejpsaw")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
# dimension = 2
mu <- c(1,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejpsaw")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
# dimension > 3
mu <- c(1,0,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejpsaw")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
})
library(testthat)
test_that("Density of PKBD", {
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejvmf")
# Check the errors
# mu
expect_error(dpkb(pkbd_dat$x, mu = c(1), rho = 0.8), 'mu must have length >= 2',fixed=TRUE)
expect_error(dpkb(pkbd_dat$x, mu = c(0,0,0), rho = 0.8), 'Input argument mu cannot be a vector of zeros',fixed=TRUE)
expect_error(dpkb(rnorm(10), mu = c(0,0,0), rho = 0.8), "x must be a matrix or a data.frame",fixed=TRUE)
expect_error(dpkb(matrix(rnorm(10),ncol=1), mu = c(0,0,0), rho = 0.8), 'x must have dimension >= 2',fixed=TRUE)
expect_error(dpkb(pkbd_dat$x, mu = c(1,0), rho = 0.8), 'number of rows of x must be equal to the length of mu',fixed=TRUE)
expect_error(dpkb(pkbd_dat$x, mu = c(1,0,0), rho = 2), 'Input argument rho must be within [0,1)',fixed=TRUE)
#------------------------------------------------------
## Generating data point on the Sphere
## and computing the densities
den <- dpkb(pkbd_dat$x, mu, rho)
expect_equal(dim(den),c(size,1))
expect_false(any(den<0))
den <- dpkb(data.frame(pkbd_dat$x), mu, rho)
expect_equal(dim(den),c(size,1))
expect_false(any(den<0))
log_den <- dpkb(pkbd_dat$x, mu, rho, logdens = TRUE)
expect_equal(dim(log_den),c(size,1))
expect_false(any(log_den>0))
})
roxygen2::roxygenize()
# dimension = 2
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2), matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4), "The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
library(QuadratiK)
?summary_stat
debug(summary_stat)
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
roxygen2::roxygenize()
debug(summary_stat)
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
roxygen2::roxygenize()
with(df, pl <- ggplot(df, aes_string(x = V1, y = V2, color = as.factor(clusters))) +
geom_point() +
theme_minimal() +
labs(color = "Cluster");print(pl))
roxygen2::roxygenize()
roxygen2::roxygenize()
dat <- generate_SN(d = 2, 100, 100, c(0,0),c(0,0), 1, 1, 0)
roxygen2::roxygenize()
devtools::load_all(".")
roxygen2::roxygenize()
devtools::document()
devtools::load_all(".")
devtools::build_manual()
library(QuadratiK)
library(testthat)
# normality
result <- select_h(x = matrix(rnorm(20),ncol=2), alternative="location")
library(QuadratiK)
# normality
result <- select_h(x = matrix(rnorm(20),ncol=2), alternative="location")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "matrix")
expect_equal(class(result$power), "data.frame")
# two-sample
result <- select_h(x = matrix(rnorm(20),ncol=2), y = matrix(rnorm(20),ncol=2), alternative="skewness")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
# k-sample
result <- select_h(x = matrix(rnorm(30),ncol=2), y = rep(c(1,2,3),each=5), alternative="scale")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
roxygen2::roxygenize()
devtools::document()
# Test 1: Verify Error on Invalid Input
test_that("Error on invalid method input", {
expect_error(select_h(x = matrix(rnorm(100), ncol = 2),
alternative = "invalid"),
"The alternative argument should be one of 'location', 'scale' or
'skewness'", fixed=TRUE)
# x is not numeric
expect_error(select_h(x = "invalid", alternative="skewness"), "x must be numeric", fixed=TRUE)
y <- matrix(rnorm(90), ncol = 3)
expect_error(select_h(matrix(rnorm(100), ncol = 2), y, alternative="skewness"),"'x' and 'y' must have the same number of columns.", fixed=TRUE)
x <- matrix(rnorm(100), ncol = 2)
y <- rep(c(1,2), each=20)
expect_error(select_h(x, y, alternative="skewness"),"'x' and 'y' must have the same number of rows.", fixed=TRUE)
y <- rep(c(1,2), each=25)
expect_error(select_h(x, y, alternative="skewness", delta_dim=c(1,2,1)),"delta_dim must be 1 or a numeric vector of length equal to the
number of columns of pooled.", fixed=TRUE)
})
## # Test 1: test for select_h
test_that("Select h", {
# normality
result <- select_h(x = matrix(rnorm(20),ncol=2), alternative="location")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
# two-sample
result <- select_h(x = matrix(rnorm(20),ncol=2), y = matrix(rnorm(20),ncol=2), alternative="skewness")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
# k-sample
result <- select_h(x = matrix(rnorm(30),ncol=2), y = rep(c(1,2,3),each=5), alternative="scale")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
})
