#'
#' @srrstats {G5.2,G5.2a,G5.2b} all the error and warning messages are tested
#' @srrstats {G5.5} random seed
#' @srrstats {G5.6} expected results
#' @srrstats {G5.8} edge conditions
#' @noRd
library(testthat)
# Test 1: Error on Invalid x Input
test_that("Error on invalid x input", {
set.seed(123)
expect_error(pk.test(x = "Not matrix", rho = 0.5),
"x must be numeric", fixed=TRUE)
expect_error(pk.test(x = rnorm(50), rho = 0.5),
"x must be a matrix or a data.frame with dimension greater than 1.",
fixed=TRUE)
})
set.seed(123)
pk.test(x = "Not matrix", rho = 0.5)
expect_error(pk.test(x = "Not matrix", rho = 0.5),
"x must be numeric", fixed=TRUE)
pk.test(x = rnorm(50), rho = 0.5)
# Test 1: Error on Invalid x Input
test_that("Error on invalid x input", {
set.seed(123)
expect_error(pk.test(x = "Not matrix", rho = 0.5),
"x must be numeric", fixed=TRUE)
expect_error(pk.test(x = rnorm(50), rho = 0.5),
"x must be a matrix or a data.frame with dimension greater
than 1.",
fixed=TRUE)
})
# Test 2: Error on Invalid Quantile Input
test_that("Error on invalid Quantile input", {
set.seed(123)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = 0.5,
Quantile = 1.1), "Quantile must be in (0,1]",
fixed=TRUE)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = 0.5,
Quantile = -1), "Quantile must be in (0,1]",
fixed=TRUE)
})
# Test 3: Error on Invalid rho Input
test_that("Error on invalid rho input", {
set.seed(123)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = -0.1),
"rho must be in (0,1)", fixed=TRUE)
expect_error(pk.test(x = matrix(rnorm(100), ncol=2), rho = 2),
"rho must be in (0,1)", fixed=TRUE)
})
# Test 4: Handling Vector x Input
test_that("Handle vector x input correctly", {
set.seed(123)
expect_s4_class(pk.test(x = matrix(rnorm(100), ncol = 2), rho = 0.5),
"pk.test")
expect_s4_class(pk.test(x = data.frame(matrix(rnorm(100), ncol = 2)),
rho = 0.5), "pk.test")
})
# Test 5: Main Functionality with Valid Inputs
test_that("Functionality with valid inputs", {
size <- 100
d <- 3
set.seed(123)
x_sp <- sample_hypersphere(d, n_points=size)
unif_test <- pk.test(x_sp,rho=0.8)
expect_s4_class(unif_test, "pk.test")
expect_true(is.numeric(unif_test@Un))
expect_true(is.numeric(unif_test@Vn))
expect_true(unif_test@H0_Un)
# test show method
output <- capture.output(show(unif_test))
expect_true(any(grepl("H0 is rejected: ", output)))
expect_true(any(grepl("Statistic Un: ", output)))
expect_true(any(grepl("Statistic Vn: ", output)))
# test summary method
s <- summary(unif_test)
expect_type(s$summary_tables, "list")
expect_equal(nrow(s$test_results), 2)
})
#' Test for pkbc
#'
#' Clustering on the Sphere
#'
#' @srrstats {G5.2,G5.2a,G5.2b} all the error and warning messages are tested
#' @srrstats {G5.5} random seed
#' @srrstats {G5.6} expected results
#' @srrstats {G5.8} edge conditions
#' @noRd
library(testthat)
# Test 1: Verify Error on Invalid inputs
test_that("Error is thrown for invalid inputs", {
set.seed(123)
dat <- matrix(rnorm(100),ncol=2)
#Invalid nClust
expect_error(pkbc(dat, nClust = 0),
"Values in the input parameter nClust must be
greater than 0")
expect_error(pkbc(dat),
"Input parameter nClust is required. Provide one specific
value or a set of possible values.")
#Invalid maxIter
expect_error(pkbc(dat, nClust=2,maxIter=0),
"Input parameter maxIter must be greater than 0")
#Invalid initMethod
expect_error(pkbc(dat, nClust=2,initMethod="Invalid"),
'Unrecognized value "Invalid" in input
parameter initMethod.')
#Invalid numInit
expect_error(pkbc(dat, nClust=2,numInit=0),
"Input parameter numInit must be greater than 0")
})
set.seed(123)
dat <- matrix(rnorm(100),ncol=2)
#Invalid nClust
expect_error(pkbc(dat, nClust = 0),
"Values in the input parameter nClust must be
greater than 0")
pkbc(dat, nClust = 0)
#Invalid nClust
expect_error(pkbc(dat, nClust = 0),
"Values in the input parameter nClust must be
greater than 0", fixed=TRUE)
pkbc(dat)
expect_error(pkbc(dat),
"Input parameter nClust is required. Provide one specific
value or a set of possible values.")
pkbc(dat, nClust=2,maxIter=0)
pkbc(dat, nClust=2,initMethod="Invalid")
set.seed(123)
dat <- matrix(rnorm(100),ncol=2)
#Invalid nClust
expect_error(pkbc(dat, nClust = 0),
"Values in the input parameter nClust must be
greater than 0", fixed=TRUE)
expect_error(pkbc(dat),
"Input parameter nClust is required. Provide one specific
value or a set of possible values.", fixed=TRUE)
#Invalid maxIter
expect_error(pkbc(dat, nClust=2,maxIter=0),
"Input parameter maxIter must be greater than 0")
#Invalid initMethod
expect_error(pkbc(dat, nClust=2,initMethod="Invalid"),
'Unrecognized value "Invalid" in input
parameter initMethod.')
#Invalid numInit
expect_error(pkbc(dat, nClust=2,numInit=0),
"Input parameter numInit must be greater than 0")
#' Test for pkbc
#'
#' Clustering on the Sphere
#'
#' @srrstats {G5.2,G5.2a,G5.2b} all the error and warning messages are tested
#' @srrstats {G5.5} random seed
#' @srrstats {G5.6} expected results
#' @srrstats {G5.8} edge conditions
#' @noRd
library(testthat)
# Test 1: Verify Error on Invalid inputs
test_that("Error is thrown for invalid inputs", {
set.seed(123)
dat <- matrix(rnorm(100),ncol=2)
#Invalid nClust
expect_error(pkbc(dat, nClust = 0),
"Values in the input parameter nClust must be
greater than 0", fixed=TRUE)
expect_error(pkbc(dat),
"Input parameter nClust is required. Provide one specific
value or a set of possible values.", fixed=TRUE)
#Invalid maxIter
expect_error(pkbc(dat, nClust=2,maxIter=0),
"Input parameter maxIter must be greater than 0")
#Invalid initMethod
expect_error(pkbc(dat, nClust=2,initMethod="Invalid"),
'Unrecognized value "Invalid" in input
parameter initMethod.')
#Invalid numInit
expect_error(pkbc(dat, nClust=2,numInit=0),
"Input parameter numInit must be greater than 0")
})
# Test 2: Verify Error on Invalid data
test_that("Error is thrown for invalid data", {
set.seed(123)
dat <- matrix(rnorm(6),ncol=2)
#Invalid nClust
expect_error(pkbc(dat, nClust = 4),
'Only 3 unique observations. When initMethod = "sampleData", must have more
than numClust unique observations.')
})
pkbc(dat, nClust = 4)
set.seed(123)
dat <- matrix(rnorm(6),ncol=2)
pkbc(dat, nClust = 4)
# Test 2: Verify Error on Invalid data
test_that("Error is thrown for invalid data", {
set.seed(123)
dat <- matrix(rnorm(6),ncol=2)
#Invalid nClust
expect_error(pkbc(dat, nClust = 4),
'Only 3 unique observations. When initMethod = "sampleData", must have more
than numClust unique observations.', fixed=TRUE)
})
# Test 3: Test for valid input
test_that("Function works for valid input", {
set.seed(123)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
result <- pkbc(dat, nClust = 2)
expect_s4_class(result, "pkbc")
expect_true(all(result@res_k$postProbs >= 0 & result@res_k$postProbs <= 1))
expect_type(result@res_k[[2]]$LogLik, "double")
})
# Test 4: Test for stopping rule
test_that("Function respects the stopping rule", {
set.seed(123)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
result_loglik <- pkbc(dat, nClust = 3, stoppingRule = 'loglik')
result_max <- pkbc(dat, nClust = 3, stoppingRule = 'max')
result_memb <- pkbc(dat, nClust = 3, stoppingRule = 'membership')
expect_true(class(result_loglik)== "pkbc")
expect_true(class(result_max)== "pkbc")
expect_true(class(result_memb)== "pkbc")
expect_error(pkbc(dat, nClust = 3, stoppingRule = 'prova'))
})
# Test 5: Test for clustering algorithm
test_that("Clustering algorithm works", {
set.seed(123)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
pkbd_res<- pkbc(dat, 3)
expect_true(class(pkbd_res)== "pkbc")
expect_type(pkbd_res@res_k, "list")
})
test_that("Random Generation from PKBD works", {
# Check the errors
set.seed(123)
expect_error(rpkb(10, mu = c(1,0,0), rho = 2),
'Input argument rho must be within [0,1)',fixed=TRUE)
expect_error(rpkb(10, mu = c(0,0,0), rho = 0.8),
'Input argument mu cannot be a vector of zeros',fixed=TRUE)
expect_error(rpkb(-10, mu = c(1,0,0), rho = 0.8),
'n must be a positive integer',fixed=TRUE)
expect_error(rpkb(10, mu = c(1,0,0), rho = 0.8, method = "invalid"),
'Unknown method',fixed=TRUE)
#------------------------------------------------------
## Generating data point on the Sphere
## "rejvmf"
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejvmf")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
## "rejacg"
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejacg")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
## "rejpsaw"
size <- 100
rho <- 0.8
mu <- c(1,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejpsaw")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
# dimension = 2
mu <- c(1,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejpsaw")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
# dimension > 3
mu <- c(1,0,0,0)
pkbd_dat <- rpkb(size, mu = mu, rho = rho, method = "rejpsaw")
expect_equal(dim(pkbd_dat$x),c(size,length(mu)))
expect_true(is.matrix(pkbd_dat$x))
expect_equal(rowSums(pkbd_dat$x^2), rep(1,size))
})
test_that("Random Generation from PKBD works", {
#------------------------------------------------------
## Generating data point on the Sphere
## and computing the densities
size <- 100
d <- 3
x_sp <- sample_hypersphere(d, size)
expect_equal(dim(x_sp),c(size,d))
expect_true(any(rowSums(x_sp^2) ==1))
})
#' Test for select_h
#'
#'
#' @srrstats {G5.2,G5.2a,G5.2b} all the error and warning messages are tested
#' @srrstats {G5.5} random seed
#' @noRd
library(testthat)
# Test 1: Verify Error on Invalid Input
test_that("Error on invalid method input", {
set.seed(123)
expect_error(select_h(x = matrix(rnorm(100), ncol = 2),
alternative = "invalid"),
"The alternative argument should be one of 'location', 'scale' or
'skewness'", fixed=TRUE)
# x is not numeric
expect_error(select_h(x = "invalid", alternative="skewness"),
"x must be numeric", fixed=TRUE)
x <- matrix(rnorm(100), ncol = 2)
y <- matrix(rnorm(90), ncol = 3)
expect_error(select_h(x, y, alternative="skewness"),
"'x' and 'y' must have the same number of columns.",
fixed=TRUE)
x <- matrix(rnorm(100), ncol = 2)
y <- rep(c(1,2), each=20)
expect_error(select_h(x, y, alternative="skewness"),
"'x' and 'y' must have the same number of rows.", fixed=TRUE)
y <- rep(c(1,2), each=25)
expect_error(select_h(x, y, alternative="skewness", delta_dim=c(1,2,1)),
"delta_dim must be 1 or a numeric vector of length equal to the
number of columns of pooled.", fixed=TRUE)
})
## # Test 1: test for select_h
test_that("Select h", {
set.seed(123)
# normality
result <- select_h(x = matrix(rnorm(20),ncol=2), alternative="location")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
# two-sample
result <- select_h(x = matrix(rnorm(20),ncol=2),
y = matrix(rnorm(20),ncol=2), alternative="skewness")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
# k-sample
result <- select_h(x = matrix(rnorm(30),ncol=2), y = rep(c(1,2,3),each=5),
alternative="scale")
expect_equal(class(result$h_sel), "numeric")
expect_equal(class(result$power), "data.frame")
})
# Test 1: Test for summary_stat
test_that("summary_stat test", {
# dimension = 2
dat<-rbind(matrix(rnorm(50),ncol=2),
matrix(rnorm(50,4),ncol=2),
matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4),
"The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 2)
expect_equal(length(res2$metrics), 2)
# dimension = 3
dat<-rbind(matrix(rnorm(60),ncol=3),
matrix(rnorm(60,4),ncol=3),
matrix(rnorm(60,2),ncol=3))
y <- rep(c(1,2,3),each=20)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 3)
expect_equal(length(res2$metrics), 3)
# dimension = 4
dat<-rbind(matrix(rnorm(60),ncol=4),
matrix(rnorm(60,4),ncol=4),
matrix(rnorm(60,2),ncol=4))
y <- rep(c(1,2,3),each=15)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 4)
expect_equal(length(res2$metrics), 4)
})
# Test 1: Test for true.labels
test_that("Clustering algorithm works", {
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
y <- rep(c(1,2),each=25)
val1 <- validation(pkbc(dat, 2), true_label = NULL, elbow.plot = FALSE)
expect_equal(nrow(val1$metrics),5)
expect_null(val1$elbow)
expect_equal(length(val1$IGP), 2)
val2 <- validation(pkbc(dat, c(2,3,4)), true_label = y, elbow.plot = TRUE)
expect_equal(nrow(val2$metrics),8)
expect_equal(length(val2$IGP), 4)
})
library(srr)
srr_stats_roxygen()
x
roxygen2::roxygenise()
install.packages("pkgdown")
usethis::use_pkgdown()
pkgdown::build_site()
roxygen2::roxygenise()
pkgdown::build_site()
a <- list("1","2")
is.vector(a)
true_label <- list("1","2")
(is.factor(true_label) | is.vector(true_label)) &!is.list(true_label)
!is.list(true_label)
true_label <- factor("1","2")
true_label
true_label <- factor(rep(c("1","2"),5))
true_label
is.vector(true_label)
is.factor(true_label)
true_label <- as.factor(as.numeric(true_label))
A <-matrix(c(1,2,3,4),nrow=2)
is.numeric(A)
a <- 3
is.vector(a)
is.vector(A)
a <- data.frame(c(1,NaN))
a
b <- as.matrix(a)
b
is.numeric(b)
a <- data.frame(c(1,inf))
a <- data.frame(c(1,Inf))
a
b <- as.matrix(a)
is.numeric(b)
b
?any
roxygen2::roxygenise()
devtools::build_vignettes()
devtools::document()
devtools::document()
roxygen2::roxygenise()
debug(roxygen2::roxygenise())
roxygen2::roxygenise()
devtools::check()
remove.packages("QuadratiK")
devtools::check()
roxygen2::roxygenise()
val1 <- validation(pkbc(dat, 2), true_label = NULL, elbow.plot = FALSE)
dat<-rbind(matrix(rnorm(50),ncol=2), matrix(rnorm(50,4),ncol=2))
y <- rep(c(1,2),each=25)
val1 <- validation(pkbc(dat, 2), true_label = NULL, elbow.plot = FALSE)
expect_equal(nrow(val1$metrics),5)
library(testthat)
expect_equal(nrow(val1$metrics),5)
expect_null(val1$elbow)
expect_equal(length(val1$IGP), 2)
val2 <- validation(pkbc(dat, c(2,3,4)), true_label = y, elbow.plot = TRUE)
expect_equal(nrow(val2$metrics),8)
expect_equal(length(val2$IGP), 4)
# dimension = 2
dat<-rbind(matrix(rnorm(50),ncol=2),
matrix(rnorm(50,4),ncol=2),
matrix(rnorm(50,2),ncol=2))
y <- rep(c(1,2,3),each=25)
pkbd_res<- pkbc(dat, c(2,3))
expect_error(summary_stat(pkbd_res, 4),
"The provided pkbc object does not contain results for the requested
number of clusters")
res1 <- summary_stat(pkbd_res, 3, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 2)
expect_equal(length(res2$metrics), 2)
# dimension = 3
dat<-rbind(matrix(rnorm(60),ncol=3),
matrix(rnorm(60,4),ncol=3),
matrix(rnorm(60,2),ncol=3))
y <- rep(c(1,2,3),each=20)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res1$metrics), 3)
expect_equal(length(res2$metrics), 3)
# dimension = 4
dat<-rbind(matrix(rnorm(60),ncol=4),
matrix(rnorm(60,4),ncol=4),
matrix(rnorm(60,2),ncol=4))
y <- rep(c(1,2,3),each=15)
pkbd_res<- pkbc(dat, c(2,3))
res1 <- summary_stat(pkbd_res, 2, true_label = NULL)
expect_equal(length(res1$metrics), 4)
res2 <- summary_stat(pkbd_res, 3, true_label = y)
expect_equal(length(res2$metrics), 4)
devtools::build_vignettes()
devtools::build_manual()
devtools::load_all()
devtools::document()
roxygen2::roxygenise()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenise()
library(pkgcheck)
x <- pkgcheck()
x <- pkgcheck()
summary(x)
x
roxygen2::roxygenise()
roxygen2::roxygenise()
library(pkgcheck)
x <- pkgcheck()
x <- pkgcheck()
summary(x)
x
library(autotest)
b <- autotest_package()
library(srr)
srr_stats_pre_submit()
srr_report()
roxygen2::roxygenise()
