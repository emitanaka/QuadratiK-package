metrics[[length(metrics)+1]] <- res
}
if (ncol(x) == 2) {
df <- data.frame(V1 = x[,1], V2 = x[,2], clusters = as.factor(y))
pl <- ggplot(df, aes(x = df$V1, y = df$V2, color = as.factor(df$clusters))) +
geom_point() +
theme_minimal() +
labs(color = "Cluster")
print(pl)
} else if (ncol(x) == 3) {
if(!is.null(true_label)){
my_palette <- colorRampPalette(c("orange","blue", "green", "red"))  # Gradient from blue to green to red
col_pal <- my_palette(k*2)
layout3d(matrix(1:2, ncol = 2))
next3d()
plot3d(x[,1], x[,2], x[,3], col = col_pal[y], size = 4)
title3d("Final membership", font=2,line = 7, cex = 3)
rgl.spheres(0, col = "transparent", alpha = 0.2)
next3d()
plot3d(x[,1], x[,2], x[,3], col = col_pal[true_label+k], size = 4)
title3d("True label", line = 7, cex = 3, font=2)
rgl.spheres(0 , col = "transparent", alpha = 0.2)
} else {
open3d()
plot3d(x[,1], x[,2], x[,3], col = y, size = 4)
rgl.spheres(0, col = "transparent", alpha = 0.2)
}
} else {
pca_result <- PcaLocantore(x)
pca_data <- data.frame(PC1 = pca_result@scores[,1], PC2 = pca_result@scores[,2], PC3 = pca_result@scores[,3])
#pca_result <- prcomp(x)  # Replace with spherical PCA if available
#pca_data <- data.frame(PC1 = pca_result$x[,1], PC2 = pca_result$x[,2], PC3 = pca_result$x[,3])
pca_data <- pca_data/sqrt(rowSums(pca_data^2))
pca_data <- data.frame(pca_data, Cluster = y)
Results$pca = pca_result
my_palette <- colorRampPalette(c("orange","blue", "green", "red"))
col_pal <- my_palette(k*2)
col_pal <- sample(col_pal, length(col_pal), replace=FALSE)
if(is.null(true_label)){
open3d()
plot3d(pca_data$PC1, pca_data$PC2, pca_data$PC3, col = col_pal[y], size = 4, xlab="PC1", ylab="PC2", zlab="PC3")
title3d("Final membership", line = 7, cex = 3, font=2)
rgl.spheres(0, col = "transparent", alpha = 0.2)
} else {
layout3d(matrix(1:2, ncol = 2))
next3d()
plot3d(pca_data$PC1, pca_data$PC2, pca_data$PC3, col = col_pal[y], size = 4, xlab="PC1", ylab="PC2", zlab="PC3")
title3d("Final membership", line = 7, cex = 3, font=2)
rgl.spheres(0, col = "transparent", alpha = 0.2)
next3d()
plot3d(pca_data$PC1, pca_data$PC2, pca_data$PC3, col = col_pal[true_label+k], size = 4, xlab="", ylab="", zlab="", add=TRUE)
text3d(x=max(pca_data$PC1), y=0, z=0, text="PC1", cex=1.5)
text3d(x=0, y=max(pca_data$PC2), z=0, text="PC2", cex=1.5)
text3d(x=0, y=0, z=max(pca_data$PC3), text="PC3", cex=1.5)
title3d("True label", line = 7, cex = 3, font=2, add=TRUE)
rgl.spheres(0, col = "transparent", alpha = 0.2, add=TRUE)
}
}
Results$metrics = metrics
return(Results)
}
summary_clust <- summary_statP(res_pk,4,true_label=labels)
#' Locantore, N., Marron, J.S., Simpson, D.G. et al. Robust principal component analysis for functional data. Test 8, 1â€“73 (1999). https://doi.org/10.1007/BF02595862
#'
#' @return List with computed descriptive statistics for each variable. For d > 3, the complete results from the \code{PcaLocantore} function (package \code{rrcov}) are also returned.
#'
#' @import rgl
#' @import ggplot2
#' @importFrom grDevices colorRampPalette
#' @importFrom rrcov PcaLocantore
#'
#' @export
summary_statP <- function(object, k, true_label=NULL){
if(!(k %in% object@input$nClust)){
stop("The provided pkbc object does not contain results for the requested number of clusters")
}
x <- object@input$dat
y <- as.factor(object@res_k[[k]]$finalMemb)
metrics <- list()
Results <- list()
for(i in 1:ncol(x)){
res <- rbind(as.numeric(by(x[,i],y,mean)),
as.numeric(by(x[,i],y,sd)),
as.numeric(by(x[,i],y,median)),
as.numeric(by(x[,i],y,IQR)),
as.numeric(by(x[,i],y,min)),
as.numeric(by(x[,i],y,max))
)
res <- cbind(res, c(mean(x[,i]), sd(x[,i]), median(x[,i]), IQR(x[,i]), min(x[,i]), max(x[,i])))
res <- as.data.frame(res)
rownames(res) <- c("mean","sd", "median", "IQR", "min", "max")
colnames(res) <- c(paste("Group ",seq(1,k),sep=""), "Overall")
metrics[[length(metrics)+1]] <- res
}
if (ncol(x) == 2) {
df <- data.frame(V1 = x[,1], V2 = x[,2], clusters = as.factor(y))
pl <- ggplot(df, aes(x = df$V1, y = df$V2, color = as.factor(df$clusters))) +
geom_point() +
theme_minimal() +
labs(color = "Cluster")
print(pl)
} else if (ncol(x) == 3) {
if(!is.null(true_label)){
my_palette <- colorRampPalette(c("orange","blue", "green", "red"))  # Gradient from blue to green to red
col_pal <- my_palette(k*2)
layout3d(matrix(1:2, ncol = 2))
next3d()
plot3d(x[,1], x[,2], x[,3], col = col_pal[y], size = 4)
title3d("Final membership", font=2,line = 7, cex = 3)
rgl.spheres(0, col = "transparent", alpha = 0.2)
next3d()
plot3d(x[,1], x[,2], x[,3], col = col_pal[true_label+k], size = 4)
title3d("True label", line = 7, cex = 3, font=2)
rgl.spheres(0 , col = "transparent", alpha = 0.2)
} else {
open3d()
plot3d(x[,1], x[,2], x[,3], col = y, size = 4)
rgl.spheres(0, col = "transparent", alpha = 0.2)
}
} else {
pca_result <- PcaLocantore(x)
pca_data <- data.frame(PC1 = pca_result@scores[,1], PC2 = pca_result@scores[,2], PC3 = pca_result@scores[,3])
#pca_result <- prcomp(x)  # Replace with spherical PCA if available
#pca_data <- data.frame(PC1 = pca_result$x[,1], PC2 = pca_result$x[,2], PC3 = pca_result$x[,3])
pca_data <- pca_data/sqrt(rowSums(pca_data^2))
pca_data <- data.frame(pca_data, Cluster = y)
Results$pca = pca_result
my_palette <- colorRampPalette(c("orange","blue", "green", "red"))
col_pal <- my_palette(k*2)
col_pal <- sample(col_pal, length(col_pal), replace=FALSE)
if(is.null(true_label)){
open3d()
plot3d(pca_data$PC1, pca_data$PC2, pca_data$PC3, col = col_pal[y], size = 4, xlab="PC1", ylab="PC2", zlab="PC3")
title3d("Final membership", line = 7, cex = 3, font=2)
rgl.spheres(0, col = "transparent", alpha = 0.2)
} else {
layout3d(matrix(1:2, ncol = 2))
next3d()
plot3d(pca_data$PC1, pca_data$PC2, pca_data$PC3, col = col_pal[y], size = 4, xlab="PC1", ylab="PC2", zlab="PC3")
title3d("Final membership", line = 7, cex = 3, font=2)
rgl.spheres(0, col = "transparent", alpha = 0.2)
next3d()
plot3d(pca_data$PC1, pca_data$PC2, pca_data$PC3, col = col_pal[true_label+k], size = 4, xlab="PC1", ylab="PC2", zlab="PC3")
title3d("True label", line = 7, cex = 3, font=2)
rgl.spheres(0, col = "transparent", alpha = 0.2)
}
}
Results$metrics = metrics
return(Results)
}
summary_clust <- summary_statP(res_pk,4,true_label=labels)
roxygen2::roxygenise()
library(QuadratiK)
rm(list=ls())
### Code for creating some data sets to be used for testing that the R and the
### Python implementations gives the same results.
library(QuadratiK)
library(openxlsx)
library(sn)
library(ggplot2)
library(mvtnorm)
library(rgl)
library(GGally)
head(wireless)
wire <- wireless[,-8]
labels <- wireless[,8]
wire_norm <- wire/sqrt(rowSums(wire^2))
set.seed(2468)
system.time(res_pk <- pkbc(as.matrix(wire_norm),2:10))
summary_clust <- summary_stat(res_pk,4,true_label=labels)
summary_clust$metrics
rgl.snapshot("/Users/sarac/Box/KernelTest_implementation/paper_Materials/wireless_sphere.png")
roxygen2::roxygenise()
devtools::load_all(".")
roxygen2::roxygenise()
devtools::load_all(".")
roxygen2::roxygenize()
roxygen2::roxygenise()
devtools::load_all(".")
devtools::load_all(".")
roxygen2::roxygenise()
remove.packages("QuadratiK")
library(QuadratiK)
x <- matrix(rnorm(400),ncol=4)
dim(x)
kb.test(x)
kb.test(x,h=1)
y <- matrix(rnorm(400),ncol=4)
kb.test(x,y,h=1)
kb.test(x,y)
select_h(x,y)
select_h(x,y, alternative="subsampling")
debug(select_h)
select_h(x,y, alternative="subsampling")
x
select_h(x,y, alternative="subsampling")
S_dat
skew_data
debug(objective_2)
h
pars
pars = params
pars$1
params
params <- expand.grid(Rep=rep_values, h = h_values)
params
k
l_values
k_values
select_h(x,y, alternative="skewness")
undebug(objective_2)
undebug(select_h)
kb.test(x,y, alternative = "skewness")
prova <- kb.test(x,y, alternative = "skewness")
str(prova)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all(".")
devtools::load_all(".")
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all(".")
devtools::load_all(".")
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all(".")
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all(".")
library(QuadratiK)
x <- matrix(rnorm(400),ncol=4)
y <- matrix(rnorm(400, sd = 3),ncol=4)
hist(x)
hist(y)
prova <- kb.test(x,y, alternative = "scale")
prova@h$power.plot
y <- matrix(rnorm(400, sd = 1.5),ncol=4)
prova <- kb.test(x,y, alternative = "scale")
prova@h$power.plot
debug(selct_h)
debug(select_h)
select_h(x,y,alternative="scale")
h_values
delta
mean_dat
S_dat
skew_data
results
h = 0.4
k =  1
objective_2(h, k)
delta_dim*delta[k]
delta_dim
delta[k]
roxygen2::roxygenise()
devtools::load_all(".")
library(QuadratiK)
x <- matrix(rnorm(400),ncol=4)
y <- matrix(rnorm(400),ncol=4)
prova <- kb.test(x,y, alternative = "scale")
select_h(x,y,alternative="scale")
y <- matrix(rnorm(400, sd=1.3),ncol=4)
select_h(x,y,alternative="scale")
y <- matrix(rnorm(400, sd=3),ncol=4)
select_h(x,y,alternative="scale")
kb.test(x,y, h=0.5)
kb.test(x,y, h=0.2)
kb.test(x,y, h=2)
kb.test(x,y, h=2.5)
set.seed(012424)
x <- matrix(rnorm(500),ncol=5)
set.seed(012424)
y1 <- matrix(rnorm(500),ncol=5)
set.seed(012424)
y2 <- matrix(rnorm(500, sd=1.2),ncol=5)
set.seed(012424)
y3 <- matrix(rnorm(500, sd=2),ncol=5)
write.csv(x, "C:/Users/sarac/Box/KernelTest_implementation/dataset/select_h_scale_x.csv")
write.csv(y1, "C:/Users/sarac/Box/KernelTest_implementation/dataset/select_h_scale_y1.csv")
write.csv(y2, "C:/Users/sarac/Box/KernelTest_implementation/dataset/select_h_scale_y2.csv")
write.csv(y3, "C:/Users/sarac/Box/KernelTest_implementation/dataset/select_h_scale_y3.csv")
library(QuadratiK)
remove.packages("kerneltest")
select_h(x=x, y=y1, alternative="scale")
QuadratiK::select_h(x=x, y=y1, alternative="scale")
# h_sel=1.2
QuadratiK::select_h(x=x, y=y2, alternative="scale")
# h_sel = 1.2
QuadratiK::select_h(x=x, y=y3, alternative="scale")
x <- rbind(matrix(rnorm(300, sd=1.2),ncol=3),
matrix(rnorm(600),ncol=3))
dim(x)
set.seed(012424)
x <- rbind(matrix(rnorm(300, sd=1.2),ncol=3),
matrix(rnorm(600),ncol=3))
set.seed(012424)
y <- rep(c(1,2,3), each=100)
write.csv(cbind(y,x), "C:/Users/sarac/Box/KernelTest_implementation/dataset/select_h_scale_k1.csv")
QuadratiK::select_h(x=x, y=y, alternative="scale")
debug(select_h)
QuadratiK::select_h(x=x, y=y, alternative="scale")
#' @importFrom sn rmsn
#' @import doParallel
#' @import foreach
#' @import stats
#' @import rlecuyer
#' @import ggplot2
#'
#' @useDynLib QuadratiK
#'
#' @export
select_k <- function(x, y, alternative, method="subsampling", b=0.8, B=100, delta_dim=1, delta=NULL, h_values=NULL,Nrep=50, n_cores=4, Quantile=0.95, power.plot=TRUE) {
# Convert vectors to a single column matrix
if(is.vector(x)) {
x <- matrix(x, ncol = 1)
} else if(is.data.frame(x)) {
x <- as.matrix(x)
} else if(!is.matrix(x)){
stop("x must be a matrix or a data.frame")
}
if(!is.null(y)){
if(is.vector(y) | is.factor(y)) {
y <- matrix(as.numeric(y), ncol = 1)
} else if(is.data.frame(y)) {
y <- as.matrix(y)
} else if(!is.matrix(y)){
stop("y must be a vector or a matrix")
}
} else {
stop("y must be provided.")
}
if(!(alternative %in% c("location", "scale", "skewness"))){
stop("The alternative argument should be one of 'location', 'scale' or 'skewness'")
}
n <- nrow(x)
d <- ncol(x)
d_y <- ncol(y)
if (is.null(h_values)) h_values <- seq(0.4, 3, 0.4)
if(is.null(delta)){
if(alternative=='location'){
delta <- seq(0.2,0.62,0.2)
} else if(alternative=='scale'){
delta <- 1 + seq(0.1,0.52,0.2)
} else if(alternative=='skewness'){
delta <- c(0.2, 0.3, 0.6)
}
}
if(d_y > 1){
# Check that they have the same number of columns (features):
if(ncol(x) != ncol(y)) {
stop("'x' and 'y' must have the same number of columns.")
}
m <- nrow(y)
pooled <- rbind(x, y)
} else if(d_y==1){
# if(nrow(x) != length(y)) {
#    stop("Number of rows of 'x' and the length of 'y' must coincide.")
# }
if(nrow(x) != nrow(y)) {
stop("'x' and 'y' must have the same number of rows.")
}
K <- length(unique(y))
nk <- round(n/K)
pooled <- x
}
if(length(delta_dim)==1){
delta_dim <- rep(1, d)
}else{
if (!is.numeric(delta_dim) || length(delta_dim) != d) {
stop("delta_dim must be 1 or a numeric vector of length equal to the number of columns of pooled.")
}
}
# Compute estimates of mean, covariance and skewness from the pooled sample
mean_dat <- colMeans(pooled)
S_dat <- cov(pooled)
S_dat <- diag(diag(S_dat), nrow = d, ncol = d)
skew_data <- skewness(pooled)
# Define the objective function for the alternative of the two-sample test
objective_2 <- function(h,k) {
dk <- delta_dim*delta[k]
if(alternative=='location'){
xnew <- sn::rmsn(n, xi = mean_dat, Omega = S_dat, alpha = skew_data)
ynew <- sn::rmsn(m, xi = mean_dat + dk, Omega = S_dat, alpha = skew_data)
} else if(alternative=='scale'){
xnew <- sn::rmsn(n, xi = mean_dat, Omega = S_dat, alpha = skew_data)
ynew <- sn::rmsn(m, xi = mean_dat , Omega = dk*S_dat, alpha = skew_data)
} else if(alternative=='skewness'){
xnew <- sn::rmsn(n, xi = mean_dat, Omega = S_dat, alpha = skew_data)
ynew <- sn::rmsn(m, xi = mean_dat, Omega = S_dat, alpha = skew_data+dk)
}
#x <- as.matrix(xnew[sample(n, replace = FALSE),])
#y <- as.matrix(ynew[sample(m, replace = FALSE),])
STATISTIC <- stat2sample(xnew, ynew, h, matrix(0,nrow=1),diag(1),"Nonparam")
CV <- compute_CV(B, Quantile, pooled, n, m, h, method, b)
return(STATISTIC < CV)
}
# Define the objective function for the alternative k-sample test
objective_k <- function(h,k) {
dk <- delta_dim*delta[k]
if(alternative=='location'){
mean_tilde <- mean_dat + dk
S_tilde <- S_dat
skew_tilde <- skew_data
} else if(alternative=='scale'){
mean_tilde <- mean_dat
S_tilde <- S_dat*dk
skew_tilde <- skew_data
} else if(alternative=='skewness'){
mean_tilde <- mean_dat
skew_tilde <- skew_data + dk
S_tilde <- S_dat
}
xnew <- rbind(
sn::rmsn(nk*(K-1), xi = mean_dat, Omega = S_dat, alpha = skew_data),
sn::rmsn(nk, xi = mean_tilde, Omega = S_tilde, alpha = skew_tilde))
ynew <- matrix(rep(1:K, each=nk),ncol=1)
sizes_new <- as.vector(table(ynew))
cum_size_new <- c(0,cumsum(sizes_new))
STATISTIC <- stat_ksample_cpp(xnew, ynew, h, sizes_new, cum_size_new)
CV <- cv_ksample(xnew, ynew, h, B, b, Quantile, method)
return(c(STATISTIC < CV))
}
num_cores <- as.numeric(n_cores)
registerDoParallel(cores=n_cores)
D <- length(delta)
k_values <- 1:D
rep_values <- 1:Nrep
params <- expand.grid(Rep=rep_values, h = h_values)
params <- split(params, seq(nrow(params)))
res <- data.frame(Rep=numeric(), delta=numeric(), h=numeric(), power=numeric())
pars = NULL
for(k in k_values){
results <- foreach(pars = params, .combine = rbind, .packages=c("sn", "moments", "stats", "rlecuyer","QuadratiK")) %dopar% {
h <- as.numeric(pars$h)
if(d_y > 1){
objective_result <- objective_2(h, k)
} else if(d_y == 1){
objective_result <- objective_k(h, k)
}
data.frame(Rep=pars$Rep, delta=delta[k], h=h, score=objective_result)
}
results$score <- 1 - results$score
results_mean <- aggregate(score ~ h + delta , results, mean)
names(results_mean)[3] <- "power"
res <- rbind(res,results_mean)
# Select the minimum h where power > 0.5
# If no such h exists, select the minimum h with the maximum power
min_h_power_gt_05 <- subset(results_mean, power >= 0.5)
if (nrow(min_h_power_gt_05) > 0) {
min_h <- min_h_power_gt_05$h[1]
break
} else {
min_h <- NULL
}
}
if(is.null(min_h)){
results_mean <- results_mean[order(-results_mean$power, results_mean$h), ]
min_h <- results_mean$h[1]
}
results <- list(h_sel = min_h, power = res)
pl <- ggplot(res, aes(x = h, y = power)) +
geom_line(aes(col = as.factor(delta)), linewidth = 0.9, alpha=.9) +
labs(y="Power")+
theme_minimal()+
theme_light()+
labs(color=expression(delta))+
theme(legend.title = element_text(size=16),
legend.text = element_text(size = 18),
plot.title = element_text(size = 16),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
axis.text.x = element_text(size = 11),
axis.text.y = element_text(size = 11),
strip.text = element_text(size = 14)) +
scale_color_brewer(palette='Set1')
results$power.plot <- pl
if(power.plot){
print(pl)
}
return(results)
}
select_k(x=x, y=y, alternative="scale")
library(moments)
select_k(x=x, y=y, alternative="scale")
library(doParallel)
select_k(x=x, y=y, alternative="scale")
roxygen2::roxygenize()
devtools::load_all(".")
library(QuadratiK)
## For two-sample test
set.seed(012424)
x <- matrix(rnorm(500),ncol=5)
set.seed(012424)
y1 <- matrix(rnorm(500),ncol=5)
set.seed(012424)
y2 <- matrix(rnorm(500, sd=1.2),ncol=5)
set.seed(012424)
y3 <- matrix(rnorm(500, sd=2),ncol=5)
QuadratiK::select_h(x=x, y=y1, alternative="scale")
# h_sel = 1.2
QuadratiK::select_h(x=x, y=y2, alternative="scale")
# h_sel = 1.2
QuadratiK::select_h(x=x, y=y3, alternative="scale")
set.seed(012424)
x <- rbind(matrix(rnorm(300, sd=1.2),ncol=3),
matrix(rnorm(600),ncol=3))
y <- rep(c(1,2,3), each=100)
QuadratiK::select_h(x=x, y=y, alternative="scale")
# h_sel = 1.6
QuadratiK::kb.test(x,y)
seq(0.4, 3, 0.4)
